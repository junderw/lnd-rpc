import { CreateResponse, RestoreResponse, UnlockResponse, ChangePasswordResponse, SendResponse, ChannelPoint, RequestResponse, Invoice, GetInfoResponse, ListChannelsResponse, ChannelBalanceResponse, ChannelBandwidthResponse, WalletBalanceResponse, NewAddressResponse, PayReq, ListChannelsRequest, NewAddressRequest, OpenChannelRequest, SendRequest, PaymentHash, PayReqString } from './types';
export * from './types';
export declare class LightningRpc {
    private __meta;
    private __mainRpc;
    private __unlockerRpc;
    private __domainPort;
    private __credentials;
    private __lnrpc;
    constructor(tlsCert: string, macaroonHex: string, domainPort?: string);
    static fromStrings(tlsCert: string, macaroonHex: string, domainPort?: string): LightningRpc;
    static fromFilePaths(tlsCertPath: string, macaroonPath: string, domainPort?: string): LightningRpc;
    waitForReady(): Promise<void>;
    toMain(): Promise<void>;
    toUnlocker(): Promise<void>;
    create(walletPw: string, aezeedPw?: string): Promise<CreateResponse>;
    restore(aezeedStr: string, walletPw: string, aezeedPw?: string): Promise<RestoreResponse>;
    unlock(password: string): Promise<UnlockResponse>;
    changePassword(currentPassword: string, newPassword: string): Promise<ChangePasswordResponse>;
    send(paymentRequest: string): Promise<SendResponse>;
    open(nodePubkeyString: string, localFundingAmount: number, pushSat: number): Promise<ChannelPoint>;
    request(satoshis: number): Promise<RequestResponse>;
    check(rHashStr: string): Promise<Invoice>;
    channelBandwidth(): Promise<ChannelBandwidthResponse>;
    getInfo(): Promise<GetInfoResponse>;
    listChannels(opts: ListChannelsRequest): Promise<ListChannelsResponse>;
    channelBalance(): Promise<ChannelBalanceResponse>;
    walletBalance(): Promise<WalletBalanceResponse>;
    newAddress(opts: NewAddressRequest): Promise<NewAddressResponse>;
    openChannel(opts: OpenChannelRequest): Promise<ChannelPoint>;
    sendPayment(opts: SendRequest): Promise<SendResponse>;
    addInvoice(opts: Invoice): Promise<RequestResponse>;
    lookupInvoice(opts: PaymentHash): Promise<Invoice>;
    decodePayReq(opts: PayReqString): Promise<PayReq>;
}
